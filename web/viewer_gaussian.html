<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>GeomPack Gaussian Splat Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #1a1a1a;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        #viewerContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #ff6b6b;
            padding: 20px;
            max-width: 80%;
        }

        .error.hidden {
            display: none;
        }

        #controls {
            position: absolute;
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            background: rgba(0,0,0,0.7);
            padding: 6px 12px;
            border-radius: 4px;
            z-index: 50;
        }

        #controls button {
            background: #444;
            border: none;
            color: #fff;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
        }

        #controls button:hover {
            background: #555;
        }

        .info-panel {
            position: absolute;
            top: 8px;
            left: 8px;
            background: rgba(0,0,0,0.7);
            padding: 8px 12px;
            border-radius: 4px;
            color: #aaa;
            font-size: 11px;
            font-family: monospace;
            z-index: 50;
        }

        .info-panel.hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="viewerContainer">
        <canvas id="canvas"></canvas>


        <div id="error" class="error hidden"></div>

        <div id="infoPanel" class="info-panel hidden">
            <div id="infoContent"></div>
        </div>
    </div>

    <div id="controls">
        <button id="resetCamera" title="Reset camera view">Reset View</button>
        <button id="screenshot" title="Take screenshot">Screenshot</button>
    </div>

    <!-- Load bundled gsplat.js -->
    <script src="./js/gsplat-bundle.js"></script>

    <script type="module">
        // Use the globally exported GSPLAT
        const SPLAT = window.GSPLAT;

        // DOM elements
        const canvas = document.getElementById('canvas');
        const errorEl = document.getElementById('error');
        const infoPanel = document.getElementById('infoPanel');
        const infoContent = document.getElementById('infoContent');

        // gsplat.js components
        let scene = null;
        let camera = null;
        let renderer = null;
        let controls = null;
        let animationId = null;
        let currentSplat = null;

        // Initialize the viewer
        function initViewer() {
            try {
                scene = new SPLAT.Scene();
                camera = new SPLAT.Camera();
                renderer = new SPLAT.WebGLRenderer(canvas);
                controls = new SPLAT.OrbitControls(camera, canvas);

                // Handle resize
                const resize = () => {
                    renderer.setSize(canvas.clientWidth, canvas.clientHeight);
                };
                window.addEventListener('resize', resize);
                resize();

                // Start render loop
                const frame = () => {
                    controls.update();
                    renderer.render(scene, camera);
                    animationId = requestAnimationFrame(frame);
                };
                frame();

                console.log('[GaussianViewer] Initialized successfully');
            } catch (err) {
                console.error('[GaussianViewer] Init error:', err);
                showError('Failed to initialize WebGL viewer: ' + err.message);
            }
        }

        // Show error
        function showError(message) {
            errorEl.textContent = message;
            errorEl.classList.remove('hidden');
        }

        // Store initial camera params for reset
        let initialCameraData = null;

        // Set camera from extrinsics and intrinsics
        // extrinsics: 4x4 matrix (identity for SHARP = camera at origin looking down +Z)
        // intrinsics: 3x3 matrix [[fx, 0, cx], [0, fy, cy], [0, 0, 1]]
        // splat: the loaded Gaussian splat object (optional, used for bounds)
        function setCameraFromExtrinsics(extrinsics, intrinsics, splat) {
            if (!camera || !controls) return;

            console.log('[GaussianViewer] Setting camera from extrinsics/intrinsics');
            console.log('[GaussianViewer] Extrinsics:', JSON.stringify(extrinsics));
            console.log('[GaussianViewer] Intrinsics:', JSON.stringify(intrinsics));

            // Parse extrinsics to get camera position
            // For a 4x4 extrinsics matrix [R|t], camera position in world space is -R^T * t
            // But for identity matrix, camera is simply at origin
            let camPosX = 0, camPosY = 0, camPosZ = 0;

            if (extrinsics && Array.isArray(extrinsics) && extrinsics.length === 4) {
                // Extract rotation and translation from 4x4 extrinsics
                const R = [
                    [extrinsics[0][0], extrinsics[0][1], extrinsics[0][2]],
                    [extrinsics[1][0], extrinsics[1][1], extrinsics[1][2]],
                    [extrinsics[2][0], extrinsics[2][1], extrinsics[2][2]]
                ];
                const t = [extrinsics[0][3], extrinsics[1][3], extrinsics[2][3]];

                // Camera position = -R^T * t
                camPosX = -(R[0][0] * t[0] + R[1][0] * t[1] + R[2][0] * t[2]);
                camPosY = -(R[0][1] * t[0] + R[1][1] * t[1] + R[2][1] * t[2]);
                camPosZ = -(R[0][2] * t[0] + R[1][2] * t[1] + R[2][2] * t[2]);

                console.log('[GaussianViewer] Computed camera position from extrinsics:', camPosX, camPosY, camPosZ);
            }

            // Calculate FOV and set camera focal length from intrinsics
            // intrinsics[0][0] = fx (focal length in pixels)
            // intrinsics[1][1] = fy (focal length in pixels)
            // intrinsics[1][2] = cy (principal point y = image_height / 2)
            let targetZ = 2; // default
            if (intrinsics && Array.isArray(intrinsics) && intrinsics.length >= 2) {
                const fx = intrinsics[0][0];
                const fy = intrinsics[1][1];
                const cx = intrinsics[0][2];
                const cy = intrinsics[1][2];
                const imageWidth = cx * 2;  // cx is typically image_width / 2
                const imageHeight = cy * 2; // cy is typically image_height / 2

                console.log('[GaussianViewer] Intrinsics: fx=', fx, 'fy=', fy, 'cx=', cx, 'cy=', cy);
                console.log('[GaussianViewer] Image dimensions (from intrinsics):', imageWidth, 'x', imageHeight);

                // Set camera focal length to match the original camera
                // gsplat.js uses fx/fy in screen pixels, need to scale by canvas size
                const canvasWidth = canvas.clientWidth || 512;
                const canvasHeight = canvas.clientHeight || 512;

<<<<<<< Updated upstream
                // Scale focal lengths proportionally to canvas size
                const scaledFx = fx * (canvasWidth / imageWidth);
                const scaledFy = fy * (canvasHeight / imageHeight);

                camera.data.fx = scaledFx;
                camera.data.fy = scaledFy;

                console.log('[GaussianViewer] Canvas size:', canvasWidth, 'x', canvasHeight);
                console.log('[GaussianViewer] Scaled focal lengths: fx=', scaledFx, 'fy=', scaledFy);
=======
                // Use uniform scale factor (canvas should have same aspect ratio as image)
                // This keeps fx = fy for undistorted view
                const scale = canvasWidth / imageWidth;
                const scaledF = fx * scale;  // fx and fy are equal in SHARP

                camera.data.fx = scaledF;
                camera.data.fy = scaledF;

                console.log('[GaussianViewer] Canvas size:', canvasWidth, 'x', canvasHeight);
                console.log('[GaussianViewer] Uniform scale:', scale, 'scaled focal length:', scaledF);
>>>>>>> Stashed changes

                // Calculate vertical FOV in radians for logging
                const fovY = 2 * Math.atan(imageHeight / (2 * fy));
                const fovYDeg = fovY * 180 / Math.PI;
                console.log('[GaussianViewer] Calculated FOV:', fovYDeg, 'degrees');

                // For SHARP, the scene is in front of the camera
                // Use focal length to estimate a reasonable target distance
                // The disparity range in metadata can help estimate scene depth
                // For now, use a simple heuristic based on typical SHARP output
                targetZ = Math.max(1, fy / imageHeight * 2);
                console.log('[GaussianViewer] Target Z distance:', targetZ);
            }
<<<<<<< Updated upstream

            // Determine the target position (what the camera looks at)
            // Use scene bounds center if available, otherwise use calculated targetZ
            let targetX = 0, targetY = 0;
            if (splat && splat.bounds) {
                const center = splat.bounds.center();
                targetX = center.x;
                targetY = center.y;
                targetZ = center.z;
                console.log('[GaussianViewer] Using scene center as target:', targetX, targetY, targetZ);
            }

            // For SHARP: camera is at origin, scene is at positive Z
            // The orbit controls work by having the camera orbit around a target point.
            // To get the "original image view", we set camera at the computed position
            // and look at the scene center.

            const camPos = new SPLAT.Vector3(camPosX, camPosY, camPosZ);
            const targetPos = new SPLAT.Vector3(targetX, targetY, targetZ);

=======

            // Determine the target position (what the camera looks at)
            // For the INITIAL view (matching original image), look STRAIGHT AHEAD along Z axis
            // NOT at the scene center - that would tilt the camera
            let targetX = 0, targetY = 0;
            let orbitZ = targetZ;  // For orbiting, use a closer point
            if (splat && splat.bounds) {
                const center = splat.bounds.center();
                const size = splat.bounds.size();

                // Use scene center Z for the view direction
                targetZ = center.z;

                // For orbit center, use a point closer to camera (front 1/3 of scene)
                // This makes rotation feel more natural
                const minZ = center.z - size.z / 2;
                orbitZ = minZ + size.z * 0.33;  // Front third of scene

                console.log('[GaussianViewer] Scene center:', center.x, -center.y, center.z);
                console.log('[GaussianViewer] Scene Z range:', minZ.toFixed(1), 'to', (center.z + size.z/2).toFixed(1));
                console.log('[GaussianViewer] Orbit center Z:', orbitZ.toFixed(1), '(front 1/3 of scene)');
            }

            // SHARP uses Y-down coordinate system, so flip camera Y as well
            camPosY = -camPosY;

            // For SHARP: camera is at origin, scene is at positive Z
            // The orbit controls work by having the camera orbit around a target point.
            // To get the "original image view", we set camera at the computed position
            // and look at the scene center.

            const camPos = new SPLAT.Vector3(camPosX, camPosY, camPosZ);
            // Use orbitZ for the target - closer to camera for better orbit feel
            const targetPos = new SPLAT.Vector3(targetX, targetY, orbitZ);

>>>>>>> Stashed changes
            // Store for reset
            initialCameraData = {
                position: camPos,
                target: targetPos,
                fx: camera.data.fx,
                fy: camera.data.fy
            };

<<<<<<< Updated upstream
            // Set camera position
            camera.data.position = camPos;

            // Update orbit controls to orbit around the target point
=======
            // Set camera position - IMPORTANT: must set camera.position, not camera.data.position
            // camera.position is used by OrbitControls
            // camera.data.position is used for rendering
            camera.position.x = camPosX;
            camera.position.y = camPosY;
            camera.position.z = camPosZ;

            // Update orbit controls to orbit around the target point
            // This recalculates the internal orbit state from current camera.position
>>>>>>> Stashed changes
            controls.setCameraTarget(targetPos);

            console.log('[GaussianViewer] Camera set to position:', camPosX, camPosY, camPosZ);
            console.log('[GaussianViewer] Looking at target:', targetX, targetY, targetZ);
            console.log('[GaussianViewer] This should match the original input image view');
        }

        // Load a PLY file from ArrayBuffer data
        async function loadPLYFromData(arrayBuffer, filename, extrinsics, intrinsics) {
            try {
                // Clear ALL existing objects from scene
                if (scene.objects && scene.objects.length > 0) {
                    console.log('[GaussianViewer] Clearing', scene.objects.length, 'existing objects from scene');
                    // Remove all objects (iterate backwards to avoid index issues)
                    while (scene.objects.length > 0) {
                        scene.removeObject(scene.objects[0]);
                    }
                }
                currentSplat = null;

                console.log('[GaussianViewer] Loading from data, size:', arrayBuffer.byteLength);

                // Create a blob URL from the data
                const blob = new Blob([arrayBuffer], { type: 'application/octet-stream' });
                const blobUrl = URL.createObjectURL(blob);

                // Load the PLY file from blob URL using PLYLoader
                await SPLAT.PLYLoader.LoadAsync(blobUrl, scene);

                // Clean up blob URL
                URL.revokeObjectURL(blobUrl);

                // Get the loaded splat (last object in scene)
                if (scene.objects && scene.objects.length > 0) {
                    currentSplat = scene.objects[scene.objects.length - 1];

                    // Log bounds info for debugging
                    if (currentSplat.bounds) {
                        const center = currentSplat.bounds.center();
                        const size = currentSplat.bounds.size();
                        console.log('[GaussianViewer] Scene bounds center:', center.x, center.y, center.z);
                        console.log('[GaussianViewer] Scene bounds size:', size.x, size.y, size.z);
                    }
                }

                // Set camera from extrinsics and intrinsics if provided
                if (extrinsics || intrinsics) {
                    setCameraFromExtrinsics(extrinsics, intrinsics, currentSplat);
                    if (controls) controls.update();
                }

                // Show info panel
                infoPanel.classList.remove('hidden');
                infoContent.innerHTML = `<span style="color:#6cc;">Gaussian Splat Loaded</span><br><span style="color:#888;">${filename}</span>`;

                // Notify parent
                window.parent.postMessage({
                    type: 'MESH_LOADED',
                    error: null,
                    timestamp: Date.now()
                }, '*');

                console.log('[GaussianViewer] Loaded successfully');

            } catch (err) {
                console.error('[GaussianViewer] Load error:', err);
                showError('Failed to load PLY: ' + err.message);

                window.parent.postMessage({
                    type: 'MESH_ERROR',
                    error: err.message,
                    timestamp: Date.now()
                }, '*');
            }
        }

        // Reset camera to initial position
        function resetCamera() {
            if (camera && controls) {
                if (initialCameraData) {
<<<<<<< Updated upstream
                    camera.data.position = initialCameraData.position;
                    if (initialCameraData.target) {
                        controls.setCameraTarget(initialCameraData.target);
                    }
=======
                    // Set camera.position (used by OrbitControls), not camera.data.position
                    const pos = initialCameraData.position;
                    camera.position.x = pos.x;
                    camera.position.y = pos.y;
                    camera.position.z = pos.z;

                    // Restore focal lengths
>>>>>>> Stashed changes
                    if (initialCameraData.fx) {
                        camera.data.fx = initialCameraData.fx;
                    }
                    if (initialCameraData.fy) {
                        camera.data.fy = initialCameraData.fy;
                    }
<<<<<<< Updated upstream
                    console.log('[GaussianViewer] Reset camera to initial position');
                } else {
                    // Default fallback
                    camera.data.position = new SPLAT.Vector3(0, 0, 5);
=======

                    // Set the target - this recalculates orbit state from current camera.position
                    if (initialCameraData.target) {
                        controls.setCameraTarget(initialCameraData.target);
                    }

                    console.log('[GaussianViewer] Reset camera to position:', pos.x, pos.y, pos.z);
                    console.log('[GaussianViewer] Reset camera target:', initialCameraData.target?.x, initialCameraData.target?.y, initialCameraData.target?.z);
                } else {
                    // Default fallback
                    camera.position.x = 0;
                    camera.position.y = 0;
                    camera.position.z = 5;
>>>>>>> Stashed changes
                    console.log('[GaussianViewer] Reset camera to default position (0, 0, 5)');
                }
                controls.update();
            }
        }

        // Take screenshot
        function takeScreenshot() {
            if (!renderer) return;

            try {
                const dataUrl = canvas.toDataURL('image/png');
                window.parent.postMessage({
                    type: 'SCREENSHOT',
                    image: dataUrl,
                    timestamp: Date.now()
                }, '*');
                console.log('[GaussianViewer] Screenshot captured');
            } catch (err) {
                console.error('[GaussianViewer] Screenshot error:', err);
            }
        }

        // Event listeners
        document.getElementById('resetCamera').addEventListener('click', resetCamera);
        document.getElementById('screenshot').addEventListener('click', takeScreenshot);

        // Listen for messages from parent
        window.addEventListener('message', (event) => {
            const { type, data, filename, extrinsics, intrinsics } = event.data;

            if (type === 'LOAD_MESH_DATA' && data) {
                console.log('[GaussianViewer] Received LOAD_MESH_DATA, size:', data.byteLength);
                console.log('[GaussianViewer] Extrinsics:', extrinsics);
                console.log('[GaussianViewer] Intrinsics:', intrinsics);
                loadPLYFromData(data, filename || 'gaussian.ply', extrinsics, intrinsics);
            }
        });

        // Initialize on load
        initViewer();

        console.log('[GaussianViewer] Ready - waiting for LOAD_MESH message');
    </script>
</body>
</html>
